<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="google-site-verification" content="M2S6XRgNZy5AWcjY2MUVhaCDJ8uDRDkHfly4lnaz-lI"><meta name="viewport" content="width=device-width"><title>node.js concurrency evaluation - Tushar Mathur's blog</title><link rel="alternate" href="//feed.xml" type="application/rss+xml" title="A software developer, physics enthusiast, swimmer and a car geek"><link rel="stylesheet" href="/bg.svg" type="image/svg"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/default.min.css"><link rel="stylesheet" href="/css/main.css" type="text/css"><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-39050808-1']);
_gaq.push(['_trackPageview']);

(function() {
var ga = document.createElement('script');
ga.type = 'text/javascript';
ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(ga, s);
})();

</script></head><body class="article-detail"><header class="header"><div class="top-nav"><div class="red-line"></div><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/archive.html">Archives</a></li><li><a href="/about.html">About Me</a></li></ul></div><div class="content-wrap"><h1>node.js concurrency evaluation</h1><p class="author">by <span class="author"></span>Tushar Mathur</p></div></header><div id="content"><div class="content-wrap"><article class="article"><section class="content"><p>I have been using node.js for a decent amount of time now and I had this hypothesis which I needed to validate<span class="widont">&nbsp;</span>—</p>
<blockquote>
<p>For a node.js server running on multi core system, if I flood the server with <code>n</code> concurrent requests, to compute something expensive, it would handle the traffic better if the computation can be chunked in such a way that the server can compute those <code>n</code> computations, concurrently.</p>
</blockquote>
<hr>
<p>This is <a href="https://en.wikipedia.org/wiki/Computer_multitasking">timeslicing</a>, which should be equivalent to creating threads (atleast in theory) in <code>Java</code>. In fact, that’s what <a href="https://strongloop.com/strongblog/node-js-is-faster-than-java/">node.js uses</a> for <span class="caps">IO</span> operations, so technically my server should have a much higher throughput via this<span class="widont">&nbsp;</span>approach.</p>
<p>There are different ways to implement timeslicing viz. <code>setTimeout</code>, <code>process.nextTick</code> and <code>setImmediate</code>. There are subtle differences between all the three functions but bottom line is this — passing a callback to any of these functions defers its execution by some cpu cycles. This helps in letting <span class="caps">CPU</span> breathe and perform other tasks in the mean time such as — rendering (on frontend) or making <span class="caps">HTTP</span> requests<span class="widont">&nbsp;</span>etc.</p>
<p>For starters I want to compare the performance of a fibonacci algorithm on a process. So consider the following two fibonacci implementations<span class="widont">&nbsp;</span>—</p>
<h4 id="synchronous">Synchronous</h4>
<pre><code class="language-javascript"><span class="keyword">var</span> fibonacci = <span class="function"><span class="params">n</span> =&gt;</span> {
  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {
    <span class="keyword">return</span> <span class="number">1</span>
  }
  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)
}</code></pre>
<h4 id="asynchronous">Asynchronous</h4>
<pre><code class="language-javascript"><span class="keyword">var</span> fibonacciAsync = <span class="function">(<span class="params">n, cb, slicer</span>) =&gt;</span> {
  slicer(<span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) {
      <span class="keyword">return</span> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> cb(<span class="number">1</span>))
    }
    <span class="keyword">var</span> out = []
    <span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> {
      out.push(x)
      <span class="keyword">if</span> (out.length === <span class="number">2</span>) {
        cb(out[<span class="number">0</span>] + out[<span class="number">1</span>])
      }
    }
    fibonacciAsync(n - <span class="number">1</span>, add, slicer)
    fibonacciAsync(n - <span class="number">2</span>, add, slicer)
  })
}</code></pre>
<p>The first one is the most natural way of implementing fibonacci series using recursion, the second one uses <code>slicer</code> as a param, which could be any of the time slicing functions discussed<span class="widont">&nbsp;</span>above.</p>
<p><em>Though one can optimize the algorithm as a whole to have better performance by memoizing the results, I needed something that takes a toll on node.js’s single threaded architecture and get some basic metrics out of<span class="widont">&nbsp;</span>it.</em></p>
<h4 id="test-suite">Test Suite</h4>
<pre><code class="language-javascript"><span class="keyword">var</span> suite = <span class="keyword">new</span> Benchmark.Suite()

<span class="comment">// add tests</span>
suite

  .add(<span class="string">'<span class="caps">SYNC</span>'</span>, () =&gt; {
    fibonacci(size)
  })
  .add(
    <span class="string">'<span class="caps">ASYNC</span>:process.nextTick'</span>,
    d =&gt; {
      fibonacciAsync(size, d.resolve.bind(d), process.nextTick)
    },
    {<span class="attr">defer</span>: <span class="literal">true</span>}
  )
  .add(
    <span class="string">'<span class="caps">ASYNC</span>:setTimeout'</span>,
    d =&gt; {
      fibonacciAsync(size, d.resolve.bind(d), setTimeout)
    },
    {<span class="attr">defer</span>: <span class="literal">true</span>}
  )
  .add(
    <span class="string">'<span class="caps">ASYNC</span>:setImmediate'</span>,
    d =&gt; {
      fibonacciAsync(size, d.resolve.bind(d), setImmediate)
    },
    {<span class="attr">defer</span>: <span class="literal">true</span>}
  )

  .on(<span class="string">'cycle'</span>, event =&gt; <span class="built_in">console</span>.log(<span class="built_in">String</span>(event.target)))
  .on(<span class="string">'complete'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'Fastest is '</span> + <span class="keyword">this</span>.filter(<span class="string">'fastest'</span>).pluck(<span class="string">'name'</span>))
  })
  .run({<span class="attr">async</span>: <span class="literal">true</span>})</code></pre>
<h4 id="results">Results</h4>
<pre><code class="language-bash">SYNC x 14,611,668 ops/sec ±1.01% (90 runs sampled)

ASYNC:process.nextTick x 770 ops/sec ±1.16% (42 runs sampled)

ASYNC:setTimeout x 116 ops/sec ±0.79% (80 runs sampled)

ASYNC:setImmediate x 739 ops/sec ±0.93% (78 runs sampled)

Fastest is SYNC</code></pre>
<p><em><span class="caps">NOTE</span>: that setTimeout is the worst<span class="widont">&nbsp;</span>performer</em></p>
<p>Yes that’s a no brainer, <span class="caps">SYNC</span> has to be the fastest. But wait, its almost 19,000 times faster than the fastest async! That changes quite a lot of<span class="widont">&nbsp;</span>things!</p>
<p>On the front end, sometimes when you are computing something expensive, its often suggested to chunk the computation so that the browser can do other tasks such as rendering etc. This gives an impression of snappy fast <span class="caps">UI</span>. This is perceived performance and yes I understand that in totality the task will take a lot more time to complete with this<span class="widont">&nbsp;</span>approach.</p>
<p>On the server side, I got seduced into taking the same approach, so that it is able to handle the requests concurrently. Looking at the performance difference it seems like even if it does, the difference is unbelievably high and it would definitely take up a lot more memory, deferring computation everytime and eventually get exhausted of all the<span class="widont">&nbsp;</span>resources.</p>
<blockquote>
<p>The <span class="caps">CPU</span> is taking me for spin if I give him a chance to relax, how dare<span class="widont">&nbsp;</span>he!</p>
</blockquote>
<p>Alright, things are beginning to get more clearer in my head now, but the real test of my hypothesis will be on a multi core architecture. So I hosted the same code on simple node http server and forked the process<span class="widont">&nbsp;</span>4x.</p>
<h4 id="load-test-using-nperf">Load Test using <a href="/articles/node.js-concurrency-evaluation/npmjs.com/package/nperf">nperf</a></h4>
<p>With concurrency set to 50 and averaging response times and rate of response of 1000 requests, here are the<span class="widont">&nbsp;</span>results.</p>
<table>
<thead>
<tr>
<th></th>
<th>avg</th>
<th>rate</th>
<th>memory</th>
</tr>
</thead>
<tbody><tr>
<td>async</td>
<td>751.467</td>
<td>64.80</td>
<td><span class="caps">1GB</span></td>
</tr>
<tr>
<td>sync</td>
<td>23.38</td>
<td>2028.40</td>
<td><span class="caps">240MB</span></td>
</tr>
</tbody></table>
<p>In this case, sync is still close to 30x faster than async. The results are pretty much the same for different concurrency settings and gets worse for async, as the computation gets more<span class="widont">&nbsp;</span>expensive.</p>
<p>The lesson to be learnt here is — First that my hypothesis was absurd and second that application level time slicing using the node’s event loop, will <span class="caps">NOT</span> give us the same or even near the same performance of any native node module async behaviour. Neither will it be as fast as any thread based systems like <code>java</code>. This doesn’t mean that node.js or Javascript is slower than <code>java</code> or any other threaded<span class="widont">&nbsp;</span>systems.</p>
</section></article></div></div><footer><div class="content-wrap"><div class="nav"><a href="/">« Full blog</a><a href="https://github.com/tusharmath/tusharmath.github.io/edit/develop/packages/tusharm.com/contents/articles/node.js-concurrency-evaluation//index.md">Edit »</a></div><div id="disqus_thread"></div><script>/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'tusharmcom'; // required: replace example with your forum shortname
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the<a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a class="dsq-brlink" href="http://disqus.com"></a><section class="about"><p>I constantly try to make my everyday tasks simpler and more productive, that’s why I love developing apps for free. Checkout the list of my <a href="/projects.html">projects</a> or click <a href="/about.html">here</a> to know more about me.</p>
<p>In my leisure time I like to learn about physics and cars. I practice swimming and like to be a gourmet from time to time.</p>
<br><div><a class="twitter-follow-button" href="https://twitter.com/tusharmath" data-show-count="false">Follow @tusharmath</a></div><div><iframe src="//ghbtns.com/github-btn.html?user=tusharmath&amp;type=follow" allowtransparency="true" frameborder="0" scrolling="0" width="132" height="20"></iframe></div></section><section class="copy"><p>&copy; 2020 Tushar Mathur<span> powered by&nbsp;</span><a href="http://wintersmith.io">Wintersmith</a></p></section></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script><script src="/js/analytics.js"></script></body></html>